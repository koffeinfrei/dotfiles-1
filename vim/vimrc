" Initialisation
" {{{

  set nocompatible
  set encoding=utf-8
  scriptencoding utf-8

  let s:vimdir = expand("~") . "/.vim"
  let s:has_rg = executable('rg')

  " disable defaults.vim
  let g:skip_defaults_vim = 1

  " set up pathogen
  runtime bundle/pathogen/autoload/pathogen.vim
  if !exists('g:pathogen_disabled')
    let g:pathogen_disabled = []
  endif

  " only enable tmux plugins in tmux sessions
  if empty($TMUX)
    call add(g:pathogen_disabled, 'tmux-complete')
  endif

  " neocomplete requires Vim 7.3 and Lua
  if v:version < 703 || !has('lua') || (v:version == 703 && !has('patch885'))
    call add(g:pathogen_disabled, 'neocomplete')
  endif

  " load bundles
  call pathogen#infect()

  if has('gui_running')
    " avoid loading the menu, has to be set before loading filetypes
    set guioptions+=M
  endif

  augroup vimrc
    autocmd!
  augroup END

" }}}

" General Settings
" {{{

  " file handling
  filetype plugin indent on
  set hidden
  set nobackup
  set writebackup
  set backupcopy=auto
  set modeline
  set modelines=2

  if v:version > 703 && !has('nvim')
    set cryptmethod=blowfish
  endif

  " searching
  set ignorecase
  set smartcase
  set incsearch
  set hlsearch

  if s:has_rg
    let &grepprg = "rg --smart-case --hidden --vimgrep"
  endif
  set dictionary=/usr/share/dict/words

  " store swapfiles in a central location
  set directory=~/.vim/tmp/swap//,.,/var/tmp//,/tmp//
  if !isdirectory(s:vimdir . '/tmp/swap')
    call mkdir(s:vimdir . '/tmp/swap', 'p')
  endif

  " enable persistent undo
  if has('persistent_undo')
    set undofile
    set undodir=~/.vim/tmp/undo

    if !isdirectory(&undodir)
      call mkdir(&undodir, 'p')
    endif
  endif

  " spell checking
  if has('spell')
    set nospell
    set spellfile=~/.vim/spells/en.add

    if !isdirectory(s:vimdir . '/spells')
      call mkdir(s:vimdir . '/spells', 'p')
    endif
  endif

" }}}

" Display Settings
" {{{

  " interface
  syntax on
  colorscheme desertink

  set errorbells
  set visualbell t_vb= " disable bells
  set cmdheight=1
  set synmaxcol=1000 " disable syntax highlighting on long lines
  set lazyredraw
  if !&diff
    set nocursorline
  endif

  " mouse support
  set mouse=a
  if exists('&ttymouse')
    set ttymouse=xterm2
  endif

  " increase command-line height during startup to avoid prompt on long filenames
  " set cmdheight=2
  " autocmd vimrc VimEnter * set cmdheight=1

  " windows
  set winheight=3
  set winminheight=3
  set splitbelow
  set splitright

  " disable preview window for completion
  set completeopt-=preview

  " line numbers
  set number
  set numberwidth=6
  set norelativenumber

  " scrolling
  set scrolloff=5
  set sidescrolloff=8
  set sidescroll=1
  set virtualedit+=block
  set nostartofline
  set display+=lastline

  if has('conceal')
    set concealcursor=nvc
    set conceallevel=0
  endif

  " command prompt and status line
  set showcmd
  set ruler
  set laststatus=2
  set history=1000
  set report=0
  set wildmenu
  set wildmode=list:longest,full
  set wildignore=*.pyc,*.o,*.lo,*.la,*.exe,*.swp,*.db,*.bak,*.old,*.dat,*.,tmp,*.mdb,*~,~*

  " automatically open quickfix window after commands that modify the quickfix list
  autocmd vimrc QuickFixCmdPost *grep* if len(getqflist()) | copen | endif

  " highlight trailing whitespace
  autocmd vimrc VimEnter,Colorscheme * highlight Whitespace ctermbg=235 guibg=#333333
  autocmd vimrc VimEnter,Colorscheme * match Whitespace /[^ \t]\s\+$/

  " go to last cursor position when opening files
  autocmd vimrc BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") && &ft != 'gitcommit'
                                \| exe "normal g'\"" | endif

  " window/icon titles
  set title
  set icon

  if match($TERM, '^\(tmux\|screen\)-') == 0
    let &t_ts = "\033k"
    let &t_fs = "\033\\"

    let &t_IS = "\033]0;"
    let &t_IE = "\007"
  endif

  " show the project name and relative path to the current file
  function! ProjectFilepath(short) " {{{
    let l:path = fnamemodify(expand('%'), ':p:h')
    let l:root = getcwd()

    let l:root = substitute(l:path, '^' . l:root . '/', '', '')
    let l:root = substitute(l:root, '^' . $HOME, '~', '')

    if exists('b:git_dir')
      let l:root = substitute(l:root, '^' . b:git_dir, '', '')
      let l:project = fnamemodify(b:git_dir, ':h:t')

      " only return project name
      if a:short || winwidth(0) < 60
        return l:project
      endif

      " otherwise also add the path
      if fnamemodify(b:git_dir, ':h') == l:root
        let l:root = l:project
      else
        let l:root .= ' @ ' . l:project
      endif
    endif

    return l:root
  endfunction " }}}

  let &titlestring = "%t%m%r\ ❰%{ProjectFilepath(1)}❱"
  let &iconstring = &titlestring

  " add Unicode marker for tmux navigation
  if !empty($TMUX) || !empty($SUDO_COMMAND)
    let &iconstring .= " %{mode() == 'n' || &ft == 'unite' ? '😑' : '😮'}"

    if !empty($CYGWIN)
      let &titlestring = &iconstring
    endif
  endif

" }}}

" Text Formatting
" {{{

  set formatoptions+=j
  set backspace=indent,eol,start
  set whichwrap+=<,>,[,],h,l
  set iskeyword+=$
  set selection=inclusive
  set nrformats=hex

  " indents
  set autoindent

  " tabs
  set ts=2 sts=2 sw=2
  set expandtab
  set smarttab
  set shiftround

  " matching
  set matchpairs=(:),{:},[:],<:>
  set showmatch
  runtime macros/matchit.vim
  let b:match_ignorecase = 1

  " diffing
  "set diffopt+=iwhite

  " folding
  set foldenable foldmethod=marker
  autocmd vimrc Syntax * set foldmethod=marker

" }}}

" Filetype Settings
" {{{

  autocmd vimrc FileType c,cs,cpp,php setlocal ts=3 sts=3 sw=3
  autocmd vimrc FileType python,apache,sshconfig setlocal ts=4 sts=4 sw=4
  autocmd vimrc FileType css,scss setlocal iskeyword+=%
  autocmd vimrc FileType make setlocal noexpandtab
  autocmd vimrc FileType text,markdown,mail setlocal linebreak
  autocmd vimrc FileType tex,plaintex,context setlocal lbr
  autocmd vimrc FileType gitcommit,gitrebase setlocal colorcolumn=50,72
  autocmd vimrc FileType crontab setlocal nobackup nowritebackup
  autocmd vimrc FileType puppet setlocal commentstring=#%s
  autocmd vimrc FileType help setlocal nonumber norelativenumber
  autocmd vimrc FileType org setlocal foldmethod=expr

  autocmd vimrc BufRead,BufNewFile *.es6 setlocal ft=javascript
  autocmd vimrc BufRead,BufNewFile *.axlsx,*.prawn setlocal ft=ruby

  " Ruby syntax highlighting
  let g:ruby_operators = 1
  let g:ruby_no_expensive = 1

  " Ruby auto-completion
  " let g:rubycomplete_rails = 1
  " let g:rubycomplete_buffer_loading = 1

  " PHP syntax highlighting
  let php_htmlInStrings = 1
  let php_baselib = 1
  let php_special_functions = 1
  let php_alt_comparisons = 1
  let php_alt_AssignByReference = 1
  let php_folding = 1

  " JSON shortcuts
  nnoremap ck ^ci"
  nnoremap cv $F"ci"

  " show recent log entries in commit messages
  function! s:EnhanceCommitMessage()
    " avoid line wrapping
    let textwidth = &textwidth
    let &textwidth = 0

    " return if log entries were already added
    normal gg0
    if search('^# Latest commits:$')
      return
    endif

    if !search('^# Please enter the commit message')
      return
    endif

    normal V
    call search('^# Changes to be committed:$')
    normal kkd

    normal O# Latest commits:

    let command = 'git log -n 5 --no-color --no-decorate --pretty=%s'
    for line in split(system(command), '\n')
      execute 'normal o#  - ' . line
    endfor

    normal o#
    normal gg0

    " insert new line for empty commit messages
    if search('^# Latest commits:$', 'n') == 2
      normal O
      startinsert
    endif

    let &textwidth = textwidth
  endfunction
  autocmd vimrc FileType gitcommit call <SID>EnhanceCommitMessage()

" }}}

" Commands
" {{{

  " helper to preserve search and cursor position
  command! -nargs=1 Preserve call <SID>Preserve(<args>)
  function! s:Preserve(command) " {{{
    let search=@/
    let line = line('.')
    let column = col('.')
    execute a:command
    let @/ = search
    call cursor(line, column)
  endfunction " }}}

  command! -nargs=1 PreserveSearch call <SID>PreserveSearch(<args>)
  function! s:PreserveSearch(command) " {{{
    let search=@/
    execute a:command
    let @/ = search
  endfunction " }}}

  " Replace a builtin command using cabbrev
  " http://vim.wikia.com/wiki/Replace_a_builtin_command_using_cabbrev
  command! -nargs=+ CommandAlias call <SID>CommandAlias(<f-args>)
  function! s:CommandAlias(abbreviation, expansion) " {{{
    execute 'cabbrev ' . a:abbreviation . ' <c-r>=getcmdpos() == 1 && getcmdtype() == ":" ? "' . a:expansion . '" : "' . a:abbreviation . '"<CR>'
endfunction " }}}

  CommandAlias E e
  CommandAlias E! e!
  CommandAlias Q Q
  CommandAlias Q! Q!
  CommandAlias QA qa
  CommandAlias Qa qa
  CommandAlias qA qa
  CommandAlias QA! qa!
  CommandAlias Qa! qa!
  CommandAlias qA! qa!
  CommandAlias WQ wq
  CommandAlias Wq wq
  CommandAlias wQ wq
  CommandAlias WQ! wq!
  CommandAlias Wq! wq!
  CommandAlias wQ! wq!

  " diff shortcuts for visual mode
  command! Dg diffget
  command! Dp diffput

  " shortcuts to open files externally and perform online searches
  if has('mac')
    let g:open_command = 'open'
  elseif has('unix')
    let g:open_command = 'xdg-open'
  else
    let g:open_command = 'start'
  endif
  command! -nargs=+ -complete=file_in_path Open call system(g:open_command.' ' . expand("<args>"))
  command! -nargs=+ Google call system(g:open_command.' "https://www.google.com/search?q=' . expand("<args>") . '"')
  command! -nargs=+ Dict call system(g:open_command.' "http://dict.leo.org/?lp=ende&search=' . expand("<args>") . '"')
  command! -nargs=+ Wikipedia call system(g:open_command.' "http://en.wikipedia.org/wiki/Special:Search?search=' . expand("<args>") . '"')

  " shortcuts to open tmux splits and windows
  command! -nargs=* Mux call system('mux <args>')
  command! -nargs=0 Shell    Mux -b
  command! -nargs=0 Pry      Mux -b pry
  command! -nargs=0 Server   Mux @server
  command! -nargs=0 Watcher  Mux @watcher

  " open markdown preview
  command! -nargs=0 VMD execute 'silent !vmd % &>/dev/null &' | redraw!

" }}}

" Keybindings
" {{{

  " Spacemacs escape hatch
  nmap <Space>- ,s
  nmap <Space>\| ,v
  nmap <Space><Backspace> ,c
  nmap <Space><CR> ,w

  nmap <Space>bb ,b
  nmap <Space>ff ,f
  nmap <Space>pf ,f
  nmap <Space>ph ,f
  nmap <Space>fr ,r
  nnoremap <Space>bn :bnext<CR>
  nnoremap <Space>bp :bprevious<CR>
  nnoremap <Space>bd :bd<CR>
  nnoremap <Space>bR :e<CR>
  nnoremap <Space>fs :write<CR>
  nnoremap <Space>qq :q<CR>
  nnoremap <Space>qz :q<CR>
  nnoremap <Space>qa :quitall<CR>
  nnoremap <Space>wd <C-w>c
  nnoremap <Space>ws <C-w>s
  nnoremap <Space>wv <C-w>v

  " apply macros with Q (disables the default Ex mode shortcut)
  nnoremap Q @q
  vnoremap Q :norm @q<CR>

  " run a macro over a visual selection without stopping at errors
  " https://github.com/stoeffel/.dotfiles/blob/master/vim/visual-at.vim
  xnoremap @ :<C-u>call <SID>ExecuteMacroOverVisualRange()<CR>
  function! s:ExecuteMacroOverVisualRange()
    echo "@".getcmdline()
    execute ":'<,'>normal @".nr2char(getchar())
  endfunction

  " reindent whole file
  nnoremap =+ mzgg=G`z

  " shortcut for desktop clipboard
  noremap + "+

  " jump to lines with <count><Space>
  nmap <expr> <Space> v:count ? "gg" : "<Space>"

  " don't use exact searches for */#
  noremap * g*
  noremap # g#
  noremap g* *
  noremap g# #

  " duplicate the selection
  vnoremap D y`]pgv

  " repeat command for each line in selection
  xnoremap . :normal .<CR>

  " shortcuts for diff
  nnoremap du :diffupdate<CR>

  " map Ctrl+C to Escape
  inoremap <C-c> <Esc>
  autocmd vimrc CmdWinEnter * nnoremap <buffer> <C-c> :

  " indent with Tab/Shift+Tab in visual mode
  xnoremap <Tab> >
  xnoremap <S-Tab> <

  " delete to black hole register with X
  noremap X "_d
  nnoremap XX "_dd

  " keep cursor position when yanking in visual mode
  xnoremap <silent><expr> y "ygv" . mode()

  " reselect visual block after indent
  xnoremap <silent> > >gv
  xnoremap <silent> < <gv

  " select pasted text
  nmap vp `[v`]

  " toggle paste mode with F12
  set pastetoggle=<f12>

  " navigate windows/tmux panes with Ctrl+jkhl
  function! TmuxNavigate(cmd) " {{{
    let nr = winnr()

    execute('wincmd ' . a:cmd)

    if (empty($TMUX))
      return
    elseif (nr != winnr())
      return
    endif

    let pane = str2nr(system('tmux display -p "#{pane_index}"'))
    let panes = str2nr(system('tmux display -p "#{window_panes}"'))

    if (((a:cmd == 'k' || a:cmd == 'h') && nr == 1 && pane == 1) ||
          \ ((a:cmd == 'j' || a:cmd == 'l') && nr == winnr('$') && pane == panes))
      " silent call system('tmux resize-pane -Z')
    else
      let arg = tr(a:cmd, 'hjkl', 'LDUR')
      silent call system('tmux select-pane -' . arg)
    endif
  endfunction " }}}

  nnoremap <silent> <c-h> :call TmuxNavigate('h')<CR>
  nnoremap <silent> <c-j> :call TmuxNavigate('j')<CR>
  nnoremap <silent> <c-k> :call TmuxNavigate('k')<CR>
  nnoremap <silent> <c-l> :call TmuxNavigate('l')<CR>

  " alias Ctrl-v as Ctrl-q
  noremap <C-q> <C-v>
  inoremap <C-q> <C-v>
  cnoremap <C-q> <C-v>

  " Copy & Paste shortcuts
  if has('mac')
    vnoremap <D-c> "+y
    vnoremap <D-x> "+d

    map <D-v>  "+gP
    cmap <D-v> <C-R>+

    exe 'inoremap <script> <D-v>' paste#paste_cmd['i']
    exe 'vnoremap <script> <D-v>' paste#paste_cmd['v']
  else
    vnoremap <C-c> "+ygv<Esc>
    vnoremap <C-x> "+d<Esc>

    noremap <C-v>  "+gP
    cnoremap <C-v> <C-r>+

    exe 'inoremap <script> <C-v>' paste#paste_cmd['i']
    exe 'vnoremap <script> <C-v>' paste#paste_cmd['v']
  endif

  " For CTRL-v to work autoselect must be off.
  " On Unix we have two selections, autoselect can be used.
  if !has('unix')
    set guioptions-=a
  endif

  " ,q and ,e - toggle quickfix window and location list
  nnoremap <silent> ,q :call <SID>ToggleList('Quickfix List', 'c')<CR>
  nnoremap <silent> ,e :call <SID>ToggleList('Location List', 'l')<CR>
  function! GetBufferList() " {{{
    redir =>buflist
    silent! ls
    redir END
    return buflist
  endfunction " }}}
  function! s:ToggleList(bufname, pfx) " {{{
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
      if bufwinnr(bufnum) != -1
        exec(a:pfx.'close')
        return
      endif
    endfor

    if a:pfx == 'c' && !len(getqflist())
      echohl Question
      echo "Quickfix list is empty."
      return
    elseif a:pfx == 'l' && !len(getloclist(0))
      echohl Question
      echo "Location list is empty."
      return
    endif

    let winnr = winnr()
    exec(a:pfx.'open')
    if winnr() != winnr
      wincmd p
    endif
  endfunction " }}}

  " resize quickfix windows to their content, or 20 lines maximum
  autocmd vimrc FileType qf call <SID>ResizeWindow(2, 20)
  function! s:ResizeWindow(min, max) " {{{
    let max = min([a:max, &lines / 3])
    execute max([a:min, min([max, line('$') + 1])]).'wincmd _'
  endfunction " }}}

  " Ctrl-c - remove highlighted search and redraw
  nnoremap <silent> <C-c> :nohlsearch<CR>:redraw!<CR>

  " <count>` - switch buffers
  nnoremap <silent><expr> ` v:count ? ":<C-u>b<C-r>=v:count<CR><CR>" : "`"

  " <count>~ - delete buffers
  nnoremap <silent><expr> ~ v:count ? ":<C-u>bd<C-r>=v:count<CR><CR>" : "~"

  " ,n / ,p - next/previous buffer
  nnoremap <silent> ,n :call SwitchBuffer(1)<CR>
  nnoremap <silent> ,p :call SwitchBuffer(-1)<CR>
  function! SwitchBuffer(delta)
    let buffers = []
    for nr in range(1, bufnr('$'))
      if buflisted(nr) && getbufvar(nr, 'current_syntax') != 'qf'
        call add(buffers, nr)
      end
    endfor

    if len(buffers) == 0
      return
    endif

    let position = index(buffers, bufnr('%')) + a:delta

    if position < 0
      let position = len(buffers) - 1
    elseif position > len(buffers) - 1
      let position = 0
    endif

    execute 'buffer' . buffers[position]
  endfunction

  " ,c - close current window, unless it's the only one
  nnoremap <silent> ,c :call <SID>CloseWindow()<CR>
  function! s:CloseWindow() " {{{
    " get number of visible buffers
    let buffers = len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))

    if winnr('$') > 1
      if bufname('%') == '[Command Line]'
        close
      else
        lclose
        wincmd c
      endif
    endif
  endfunction " }}}

  " ,x - close the current buffer, keeping windows
  nnoremap <silent> ,x :silent lclose<CR>:silent Bdelete<CR>

  " ,X - close the current buffer, not keeping windows
  nnoremap <silent> ,X :silent lclose<CR>:silent bd<CR>

  " ,d - open definition in new window
  nmap <silent> ,d <C-w>f

  " ,r - reload current buffer
  nnoremap <silent> ,r :edit<CR>

  " ,R - reload vimrc
  nnoremap <silent> ,R :runtime! vimrc gvimrc<CR>:nohlsearch<CR>

  " ,s - split horizontally
  nnoremap <silent> ,s :split<CR>

  " ,v - split vertically
  nnoremap <silent> ,v :vsplit<CR>

  " ,w - write current buffer
  nnoremap <silent> ,w :write<CR>:redraw<CR>

  " ,$ - clear trailing whitespace
  nnoremap <silent> ,$ :call <SID>ClearTrailingWhitespace()<CR>
  function! s:ClearTrailingWhitespace() " {{{
    Preserve 'silent %s/\s\s*$//e'
    echohl Question
    echo "Trailing whitespace cleared"
    echohl none
  endfunction " }}}

  " ,F - toggle fold method
  nnoremap <silent> ,F :call ToggleFoldMethod()<CR>
  function! ToggleFoldMethod() " {{{
    if &foldcolumn == 0
      echohl Question
      echomsg "Folding..."
      echohl none
      if &filetype == 'python'
        setlocal foldmethod=indent
      else
        setlocal foldmethod=syntax
      endif
      setlocal foldcolumn=3
    else
      setlocal foldcolumn=0 foldmethod=marker
    endif
  endfunction " }}}

  " ,g and ,G - grep the current file or path
  nnoremap <silent> ,g :call <SID>GrepWrapper('%')<CR>
  nnoremap <silent> ,G :call <SID>GrepWrapper('.')<CR>
  function! s:GrepWrapper(path) " {{{
    if a:path == '%' && empty(expand('%'))
      echo "Can't grep unsaved file."
      return
    endif

    echohl Question
    let pattern = substitute(input("Grep " . (a:path == '%' ? 'buffer' : 'recursive') . ": /", expand('<cword>')), '"', '\"', '')

    if !empty(pattern)
      echohl Question
      echo "/ searching..."
      execute 'silent! grep ' . shellescape(pattern) . ' ' . a:path . ' /dev/null'
      redraw!

      let matches = len(getqflist())
      if matches > 0
        echo matches . " " . (matches == 1 ? "match" : "matches") . " found"
      else
        echohl WarningMsg
        echo "Pattern not found: " . pattern
      endif
    endif

    echohl None
  endfunction " }}}

  " ,N - toggle line numbers
  nnoremap <silent> ,N :call <SID>ToggleLineNumbers()<CR>
  function! s:ToggleLineNumbers() " {{{
    if &number
      set nonumber norelativenumber
    else
      set number norelativenumber
    endif
  endfunction " }}}

  " ,M - preview Markdown
  nnoremap <silent> ,M :call <SID>PreviewMarkdown()<CR>
  function! s:PreviewMarkdown() " {{{
    let tmpfile = '/tmp/vim-markdown-preview.html'
    call system('grip ' . shellescape(expand('%:p')) . ' --export ' . tmpfile)

    let window = system('xdotool search --name -- " - Grip - Iceweasel"')
    if window
      call system('xdotool windowmap ' . window)
      call system('xdotool windowactivate ' . window)
      call system('xdotool key ctrl+r')
    else
      call system('iceweasel.run ' . tmpfile)
    endif
  endfunction " }}}

  " F4 / F5 - change window height
  nnoremap <silent> <F4> <C-w>+
  imap <silent> <F4> <C-o><F4>
  nnoremap <silent> <F5> <C-w>-
  imap <silent> <F5> <C-o><F5>

  " F6 / F7 - change window width
  nnoremap <silent> <F6> <C-w>>
  imap <silent> <F6> <C-o><F6>
  nnoremap <silent> <F7> <C-w><
  imap <silent> <F7> <C-o><F7>

" }}}

" Plugin Settings
" {{{

  " dispatch {{{
  let g:dispatch_no_maps = 1
  " }}}

  " org-mode {{{
  " silence warning about missing plugin
  command! -nargs=* -range SpeedDatingFormat echo
  " }}}

  " elm {{{
  let g:elm_detailed_complete = 1
  let g:elm_jump_to_error = 0
  " }}}

  " json {{{
  let g:vim_json_syntax_conceal = (&conceallevel > 0)
  let g:vim_json_syntax_concealcursor = &concealcursor
  " }}}

  " devicons {{{
  let g:webdevicons_enable_airline_tabline = 0
  let g:webdevicons_enable_airline_statusline = 0
  " }}}

  " tagbar {{{
  let g:tagbar_autoclose = 1
  let g:tagbar_compact = 1
  let g:tagbar_previewwin_pos = 'rightbelow'

  nnoremap <silent> ,t :TagbarToggle<CR>
  " }}}

  " pasta {{{
  let g:pasta_disabled_filetypes = [ 'python', 'coffee', 'markdown', 'yaml', 'slim', 'tagbar' ]
  " }}}

  " diff-enhanced {{{
  autocmd vimrc VimEnter * EnhancedDiff histogram
  " }}}

  " man {{{
  runtime ftplugin/man.vim
  " }}}

  " rails {{{
  hi! link rubyRailsARMethod Statement
  " }}}

  " incsearch {{{
  let g:incsearch#consistent_n_direction = 1
  let g:incsearch#emacs_like_keymap = 1

  map /  <Plug>(incsearch-forward)
  map ?  <Plug>(incsearch-backward)
  map g/ <Plug>(incsearch-stay)
  " }}}

  " javascript-libraries-syntax {{{
  let g:used_javascript_libs = 'jquery,requirejs'
  " }}}

  " test {{{
  let g:test#strategy = 'dispatch'

  nnoremap <silent> ,! :TestFile<CR>
  nnoremap <silent> ,@ :TestNearest<CR>
  " }}}

  " ragtag {{{
  let g:ragtag_global_maps = 1

  imap <C-]> <C-x>/
  autocmd vimrc User Ragtag silent! iunmap <buffer> <C-v>%
  autocmd vimrc User Ragtag silent! iunmap <buffer> <C-v>&
  " }}}

  " rooter {{{
  let g:rooter_manual_only = 1
  let g:rooter_change_directory_for_non_project_files = 0
  let g:rooter_use_lcd = 1
  let g:rooter_silent_chdir = 1
  let g:rooter_patterns = [
    \ 'elm-package.json',
    \ 'package.json',
    \ 'Gemfile',
    \ 'mix.exs',
    \ '.git',
    \ '.git/',
    \ '.svn/'
  \ ]

  if index(g:pathogen_disabled, 'rooter') == -1
    autocmd vimrc BufEnter * if !isdirectory(expand('%')) | Rooter
  endif
  " }}}

  " matchparen {{{
  let g:matchparen_timeout = 50
  let g:matchparen_insert_timeout = 50
  " }}}

  " tabular {{{
  noremap ,a :Tabular /
  noremap ,a{ :Tabular /{<CR>
  noremap ,a} :Tabular /}<CR>
  noremap ,a[ :Tabular /[<CR>
  noremap ,a] :Tabular /]<CR>
  noremap ,a> :Tabular /-><CR>
  noremap ,a= :Tabular /\(\|\|\)\?=\+>\?<CR>
  noremap ,a, :Tabular /,\zs/l0r1<CR>
  noremap ,a: :Tabular /[^:]:\s\zs/l0r1<CR>
  " }}}

  " netrw {{{
  let g:netrw_silent = 1
  let g:netrw_ftpmode = 'ascii'
  let g:netrw_ftp_cmd = 'ftp -p'
  let g:netrw_longlist = 1
  let g:netrw_winsize = 40
  let g:netrw_altv = 1
  let g:DrChipTopLvlMenu = 'Plugins.'
  if has('unix') && exists("$DISPLAY")
    let g:netrw_browsex_viewer = 'xdg-open'
  endif
  " }}}

  " ale {{{
  nnoremap <silent>,l :ALEToggleBuffer<CR>
  nnoremap <silent>,L :ALELint<CR>

  hi ALEWarning ctermbg=238

  let g:ale_lint_on_text_changed = 'normal'
  let g:ale_lint_on_insert_leave = 1
  let g:ale_set_balloons = 0

  let g:ale_linters = {
    \ 'typescript': [ 'tslint', 'tsserver' ]
  \ }

  let g:airline#extensions#ale#show_line_numbers = 0
  let g:airline#extensions#ale#warning_symbol = ''
  let g:airline#extensions#ale#error_symbol = ''

  " let g:syntastic_javascript_checkers = [ 'jshint' ]
  " let g:syntastic_html_checkers = [ 'htmlhint' ]
  " let g:syntastic_python_checkers = [ 'python' ]
  " let g:syntastic_elixir_checkers = [ 'dogma' ]
  " let g:syntastic_elm_checkers = [ 'elm_make' ]

  " let g:syntastic_ruby_checkers = [ 'mri' ]
  " let g:syntastic_sh_checkers = [ 'sh' ]
  " let g:syntastic_slim_checkers = []

  " let g:syntastic_puppet_puppetlint_args = '--no-documentation-check'
  " let g:syntastic_ruby_rubocop_exec = expand('~/.rbenv/shims/rubocop')
  " let g:syntastic_ruby_rubocop_args = '-D'
  " let g:syntastic_ruby_slimrb_exec = expand('~/.rbenv/shims/slimrb')
  " let g:syntastic_sass_sass_exec = expand('~/.rbenv/shims/sass')
  " let g:syntastic_sass_sass_args = '-I .'
  " let g:syntastic_scss_sass_exec = expand('~/.rbenv/shims/sass')
  " let g:syntastic_scss_sass_args = '-I .'
  " let g:syntastic_sh_shellcheck_exec = 'shellcheck'
  " let g:syntastic_sh_shellcheck_args = '-e 2032,2033,2064,2086,2139,2155'

  " autocmd vimrc BufRead,BufNewFile ~/.cdist/manifest/*,~/.cdist/type/*/*
  "     \ let b:syntastic_checkers = [ 'sh' ]

  " autocmd vimrc BufRead */app/views/**/*.js.coffee
  "   \ let b:syntastic_coffee_checkers = []
  " autocmd vimrc BufEnter *.coffee
  "   \ let g:syntastic_coffee_checkers = [ 'coffee', 'coffeelint' ]
  " }}}

  " neocomplete {{{
  if index(g:pathogen_disabled, 'neocomplete') == -1
    let g:neocomplete#data_directory = '~/.vim/tmp/neocomplete'
    let g:neocomplete#enable_at_startup = 1
    let g:neocomplete#enable_auto_select = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#auto_completion_start_length = 2

    " increase limit for tag cache files
    let g:neocomplete#sources#tags#cache_limit_size = 16777216 " 16MB

    " fuzzy completion breaks dot-repeat more noticeably
    " https://github.com/Shougo/neocomplete.vim/issues/332
    let g:neocomplete#enable_fuzzy_completion = 0

    " always use completions from all buffers
    if !exists('g:neocomplete#same_filetypes')
      let g:neocomplete#same_filetypes = {}
    endif
    let g:neocomplete#same_filetypes._ = '_'

    " enable omni-completion for more languages
    call neocomplete#util#set_default_dictionary(
      \ 'g:neocomplete#sources#omni#input_patterns', 'ruby',
      \ '[^. *\t]\.\h\w*\|\h\w*::\w*')
    call neocomplete#util#set_default_dictionary(
      \ 'g:neocomplete#sources#omni#input_patterns',
      \ 'php',
      \ '[^. \t]->\h\w*\|\h\w*::\w*')
    call neocomplete#util#set_default_dictionary(
      \ 'g:neocomplete#sources#omni#input_patterns',
      \ 'elm',
      \ '\.')

    " disable for Python
    call neocomplete#util#set_default_dictionary(
      \'g:neocomplete#sources#omni#input_patterns',
      \'python',
      \'')

    " from neocomplete.txt:
    " ---------------------

    " Plugin key-mappings.
    inoremap <expr> <C-g> neocomplete#undo_completion()
    inoremap <expr> <C-l> neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: cancel popup and insert newline.
    inoremap <silent> <CR> <C-r>=neocomplete#smart_close_popup()<CR><CR>
    " <TAB>: completion.
    inoremap <expr> <Tab> pumvisible() ? "\<C-y>" : "\<Tab>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr> <C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr> <BS>  neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr> <C-y> neocomplete#close_popup()
    inoremap <expr> <C-e> neocomplete#cancel_popup()
  endif
  " }}}

  " airline {{{
  if index(g:pathogen_disabled, 'airline') == -1
    if has('gui_running') || &t_Co > 8
      let g:airline_theme = 'desertink'
    else
      let g:airline_theme = 'dark'
    endif

    let g:airline_inactive_collapse = 0
    let g:airline_detect_paste = 0
    let g:airline_detect_iminsert = 0

    let g:airline#extensions#hunks#enabled = 0
    let g:airline#extensions#quickfix#enabled = 0
    let g:airline#extensions#whitespace#enabled = 0

    let g:airline#extensions#tagbar#enabled = 1

    let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#tabline#excludes = [ 'tagbar' ]
    let g:airline#extensions#tabline#formatter = 'unique_tail'
    let g:airline#extensions#tabline#buffer_nr_show = 1
    let g:airline#extensions#tabline#buffer_min_count = 2
    let g:airline#extensions#tabline#fnamecollapse = 0

    if has('gui_running') || exists('$TERMINATOR_UUID')
      let g:airline_powerline_fonts = 1

      let g:airline#extensions#tabline#left_sep = ''
      let g:airline#extensions#tabline#left_alt_sep = ''
    else
      " unicode symbols
      let g:airline_left_sep = '»'
      let g:airline_left_sep = '▶'
      let g:airline_right_sep = '«'
      let g:airline_right_sep = '◀'

      if !exists('g:airline_symbols')
        let g:airline_symbols = {}
      endif
      let g:airline_symbols.branch = '@'
      let g:airline_symbols.linenr = ''

      let g:airline#extensions#tabline#left_sep = g:airline_left_sep
      let g:airline#extensions#tabline#left_alt_sep = ' '
    endif

    " add space after readonly symbol
    call airline#init#bootstrap()
    let g:airline_symbols.readonly .= ' '

    let g:airline_mode_map = {
      \ '__' : '#',
      \ 'n'  : 'n',
      \ 'i'  : 'i',
      \ 'R'  : 'r',
      \ 'v'  : 'v',
      \ 'V'  : 'V',
      \ 'c'  : 'c',
      \ "\026" : 'v•b',
      \ 's'  : 's',
      \ 'S'  : 'S',
      \ "\023" : 's•b',
      \ }

    let g:airline#extensions#default#section_truncate_width = {
      \ 'b': 80
    \ }

    " hide tag in small windows
    call airline#parts#define_minwidth('tagbar', 100)

    " show file directory separately from file name
    call airline#parts#define_raw('file', '%t%m')
    call airline#parts#define_raw('filepath', '%#airline_filepath#❰%<%{ProjectFilepath(0)}❱')
    let g:airline_section_c = airline#section#create(['file', g:airline_symbols.space, 'readonly', 'filepath'])

    hi airline_filepath term=bold cterm=bold ctermfg=244 ctermbg=235 gui=bold guifg=#999999 guibg=#303030
    hi airline_filepath_inactive term=bold cterm=bold ctermfg=238 ctermbg=235 gui=bold guifg=#555555 guibg=#303030
    hi airline_filepath_insert term=bold cterm=bold ctermfg=238 ctermbg=135 gui=bold guifg=#555555 guibg=#303030

    " switch filetype and format/encoding, and only show
    " file format and encoding if it's not the default
    let g:airline_section_x = airline#section#create([
      \ 'tagbar',
      \ "%{&ff == 'unix' ? '' : WebDevIconsGetFileFormatSymbol()}%{&fenc == 'utf-8' ? '' : ' ' . &fenc}"
    \ ])
    let g:airline_section_y = airline#section#create(['%{WebDevIconsGetFileTypeSymbol()} %{&ft}'])

    " don't show position percentage
    let g:airline_section_z = airline#section#create(['windowswap', 'linenr', ':%v'])
  endif
  " }}}

  " unite {{{
  if index(g:pathogen_disabled, 'unite') == -1
    let g:unite_data_directory = '~/.vim/tmp/unite'
    let g:unite_source_rec_max_cache_files = 5000
    let g:unite_source_file_mru_long_limit = 5000

    " speed up recursive file searches
    if s:has_rg
      let g:unite_source_rec_async_command = [ 'rg', '-l', '--hidden', '' ]
      let g:unite_source_grep_command = 'rg'
      let g:unite_source_grep_default_opts = '--smart-case --hidden --vimgrep'
      let g:unite_source_grep_recursive_opt = ''
    endif

    " shortcut for bookmarks
    command! -nargs=? -complete=file Bookmark UniteBookmarkAdd <args>

    " sort file results by length
    call unite#custom#source('file', 'sorters', [ 'sorter_length' ])
    call unite#custom#source('file_rec/async', 'sorters', [ 'sorter_length' ])

    " sort buffers by number
    call unite#custom#source('buffer', 'sorters', [ 'sorter_reverse' ])

    " settings for buffers
    let g:unite_source_buffer_time_format = '(%Y-%m-%d %H:%M:%S) '

    " settings for neomru
    let g:neomru#file_mru_limit = 10
    let g:neomru#time_format = '(%Y-%m-%d %H:%M:%S) '
    let g:neomru#file_mru_ignore_pattern = 'COMMIT_EDITMSG'

    " map our keys in all Unite buffers
    autocmd vimrc FileType unite call <SID>unite_buffer_mappings()
    function! s:unite_buffer_mappings() " {{{
      " use Tab to run the default action
      nmap <silent><buffer> <Tab> <Plug>(unite_do_default_action)
      imap <silent><buffer> <Tab> <Plug>(unite_do_default_action)

      " use ,a to show all actions
      nmap <silent><buffer> ,a <Plug>(unite_choose_action)
      imap <silent><buffer> ,a <Plug>(unite_choose_action)

      " use ; to toggle insert mode
      nmap <silent><buffer> ; i
      inoremap <silent><buffer> ; <Esc>

      " use ,s and ,v to open the selection in horizontal/vertical splits
      imap <silent><buffer><expr> ,s unite#do_action('split')
      imap <silent><buffer><expr> ,v unite#do_action('vsplit')

      " use ' to start quick-match mode
      nmap <silent><buffer> ' <Plug>(unite_quick_match_default_action)
      imap <silent><buffer> ' <Plug>(unite_quick_match_default_action)

      " use C-c to close Unite
      nmap <silent><buffer> <C-c> <Plug>(unite_exit)
      imap <silent><buffer> <C-c> <Plug>(unite_exit)

      " also support C-j and C-k to move between lines
      imap <silent><buffer> <C-j> <Plug>(unite_select_next_line)
      imap <silent><buffer> <C-k> <Plug>(unite_select_previous_line)

      " use C-n and C-p to move between lines in normal mode too
      noremap <silent><buffer> <C-n> j
      noremap <silent><buffer> <C-p> k

      " use C-r to refresh Unite
      nmap <silent><buffer> <C-r> <Plug>(unite_redraw)
      imap <silent><buffer> <C-r> <Plug>(unite_redraw)
    endfunction " }}}

    " wrapper for default Unite arguments
    function! UniteWrapper(action, arguments)
      return ":\<C-u>silent! Unite -no-split -no-resize -toggle " . a:action . " " . a:arguments . "\<CR>"
    endfunction

    " ,f - show files in the current working directory and project tree
    nnoremap <silent><expr> ,f UniteWrapper('file' . (empty(expand('%')) ? '' : ':'.expand('%:.:h')) . ' file_rec/async:!' . (empty(expand('%')) ? '' : ':'.expand('%:.:h')) . ' file/new' . (empty(expand('%')) ? '' : ':'.expand('%:.:h')), '-buffer-name=unite-files -start-insert')

    " ,r - show recently edited files
    nnoremap <silent><expr> ,r UniteWrapper('file_mru:all', '-buffer-name=unite-changes -start-insert')

    " ,b - show open buffers
    nnoremap <silent><expr> ,b UniteWrapper('buffer', '-buffer-name=unite-buffers -start-insert')

    " ,B - search bundle
    nnoremap <silent><expr> ,B UniteWrapper(join(map(split(glob('{.bundle/ruby/*/{gems,bundler/gems},node_modules,vim/bundle,.vim/bundle}'), '\n'), '"file_rec/async:" . v:val'), ' '), '-buffer-name=unite-bundle -start-insert')

    " ,y - show yank history
    let g:unite_source_history_yank_enable = 1
    nnoremap <silent><expr> ,y UniteWrapper('history/yank', '-buffer-name=unite-yank-history')

    " ,T - show tags
    nnoremap <silent><expr> ,T UniteWrapper('tag', '-start-insert')

    " run ,<Space> on startup if no arguments were given
    " au VimEnter *
    "   \ if !argc() && (line2byte('$') == -1) && (v:progname =~? '^[gm]\=vim\%[\.exe]$') |
    "   \   execute "normal , " |
    "   \ endif
  endif
  " }}}

" }}}
